{
   TFile fileOutput1("Sigma_proton_output_test.root","recreate");
  gStyle->SetOptStat(0);

  // My interaction is γn → K^+ Σ^-;  Σ^- p → Σ^- p

//========================================================================================================================================================

  // Histograms

  // Beam energy distribution
  TH1D* h_Beam = new TH1D("h_Beam","Bremsstrahlung photon Beam; E [GeV]; Counts" ,200,0,5);

  // Invariant mass histograms to reconstruct Σ-
  TH1D* h_inv_Sigma = new TH1D("h_inv_Sigma","Invariant mass of #Sigma; Mass[GeV/c^2]",200,0,2);

  // scattering angle distributions
  TH1D* h_Kaon_angles  = new TH1D("h_Kaon_angles","K^{+} scattering angle; Scattering angle (degree)" ,200,0,180);
  TH1D* h_Sigma_angles = new TH1D("h_Sigma_angles","#Sigma^{-} scattering angle; Scattering angle (degree)" ,200,0,180);

  // Momentum Histograms
  TH1D* h_Kaon_rho  = new TH1D("h_Kaon_rho","K^{+} momentum; Momentum [GeV/c]; Counts" ,200,0,5);
  TH1D* h_Sigma_rho = new TH1D("h_Sigma_rho","#Sigma^{-} momentum; Momentum [GeV/c]; Counts" ,200,0,5);
  TH1D* h_Scattered_Sigma_rho = new TH1D("h_Scattered_Sigma_rho","Scattered #Sigma^{-} momentum; Momentum [GeV/c]; Counts" ,200,0,5);
  TH1D* h_Beam_rho = new TH1D("h_Beam_rho","Photon Beam momentum; Momentum [GeV/c]" ,200,0,5);

  // Angular dependence for all the particles
  TH2D* h_Kaon_Plus        = new TH2D("h_Kaon_Plus","Angular dependence of K^{+}; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH2D* h_Sigma_Minus      = new TH2D("h_Sigma_Minus","Angular dependence of secondary Beam #Sigma^{-}; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH2D* h_Scattered_Sigma  = new TH2D("h_Scattered_Sigma","Angular dependence of scattered #Sigma^{-}; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH2D* h_Scattered_Proton = new TH2D("h_Scattered_Proton","Angular dependence of scattered proton; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH2D* h_Neutron_Sigma    = new TH2D("h_Neutron_Sigma","Angular dependence of n (#Sigma); #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH2D* h_Pi_Minus_Sigma   = new TH2D("h_Pi_Minus_Sigma","Angular dependence of π^{-} (#Sigma); #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);

  // Acceptance Histograms
  TH1D* h_acceptance_Beam              = new TH1D("h_acceptance_Beam","Acceptance of photon Beam; #Theta (degrees); #rho (GeV/c)",200,0,5);
  TH2D* h_acceptance_Kaon_Plus         = new TH2D("h_acceptance_Kaon_Plus","Acceptance of K^{+}; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH1D* h_acceptance_Scattered_Sigma   = new TH1D("h_acceptance_Scattered_Sigma","Acceptance of #Sigma^{-} Beam",200,0,5);
  TH2D* h_acceptance_Scattered_Proton  = new TH2D("h_acceptance_Scattered_Proton","Acceptance of the scattered proton; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);
  TH2D* h_acceptance_Pi_Minus_Sigma    = new TH2D("h_acceptance_Pi_Minus_Sigma","Acceptance of #Sigma^{-}-produced #pi^{-}; #Theta (degrees); #rho (GeV/c)",200,0,180,200,0,5);

  // Constrained Histograms
  TH1D* h_constrained_Beam              = new TH1D("h_constrained_Beam","Constrained photon Beam",200,0,5);
  TH2D* h_constrained_Kaon_Plus         = new TH2D("h_constrained_Kaon_Plus","Constrained K^{+}",200,0,180,200,0,5);
  TH1D* h_constrained_Scattered_Sigma   = new TH1D("h_constrained_Scattered_Sigma","Constrained scattered #Sigma^{-}",200,0,5);
  TH2D* h_constrained_Scattered_Proton  = new TH2D("constrained_Scattered_Proton","Constrained scattered proton", 200,0,180,200,0,5);
  TH2D* h_constrained_Pi_Minus_Sigma    = new TH2D("h_constrained_Pi_Minus_Sigma","Constrained #pi^{-}",200,0,180,200,0,5);

  // Path Length and Decay Vertex Histograms
  TH3D* h_xyz             = new TH3D("h_xyz", "Uniformly distributed xyz points;x;y;z", 200, -4, 4, 200, -4, 4, 200, -20, 50);
  TH1D* h_path            = new TH1D("h_path","Path length; distance (cm); ",200,-40,40);
  TH1D* h_decaypath       = new TH1D("h_decaypath","#Sigma^{-} Decay path; #Sigma^{-} path (cm); ",200,-40,40);
  TH2D* h_decay_xy        = new TH2D("h_decay_xy","x-y veretex #Sigma^{-}; x-vertex (cm); y-vertex (cm)",200,-40,40,200,-40,40);
  TH1D* h_decay_z         = new TH1D("h_decay_z","z-vertex decay #Sigma^{-}; z-coordinate (cm)",200,-20,100);
  TH2D* h_sigma_phi_xy    = new TH2D("h_sigma_phi_xy", "#phi of #Sigma^{-} vs X-Y component of path length; \phi (degrees); length (cm)",200,0,50,200,0,180);
  TH2D* h_sigma_theta_z   = new TH2D("h_sigma_theta_z", "#theta of #Sigma^{-} vs Z component of path length; #theta (degrees); length (cm)",200,0,50,200,0,180);
  TH2D* h_path_theta      = new TH2D("h_path_theta","#theta of #Sigma^{-} vs path length; #theta (degrees); path length (cm)",200,0,280,200,0,50);
  TH2D* h_decaypath_theta = new TH2D("h_decaypath_theta","#theta of #Sigma^{-} decay vs path length; #theta (degrees); length (cm)",200,0,50,200,0,50);

  // Cross Sections Histograms

//========================================================================================================================================================

  // How many events to simulate and percentage completed
  Int_t nevents = 100;  // increase this
  Int_t Percentage = nevents/100;

//========================================================================================================================================================

  // Generating the events which describe the interaction is the first step of the simulation and is done using the class TLorentzVector
  TLorentzVector Beam, target, proton_trgt; // initial-state particles
  TLorentzVector *Kaon_Plus, *Sigma_Minus; // First vertex particles
  TLorentzVector *Scattered_Sigma, *Scattered_Proton; // second veretex
  TLorentzVector *Neutron_Sigma, *Pi_Minus_Sigma; // Second vertex particles

  // Making Weights
  Double_t Phasespace_Weight_1;

  // TH1D * Weight=new TH1D("Weight","",10,-1,11);
//========================================================================================================================================================

  // Defining the four-momentum vector of the target in GeV (Px,Py,Pz,M)
  target.SetXYZM(0,0,0,0.93957);     // quasi-free neutron in deuterium target
  proton_trgt.SetXYZM(0,0,0,0.93827); // secondary target

  // Defining the masses of the final-state particles using particle properties obtained from PDG
  Double_t Masses_1[2] = {0.49368,1.19745}; // K^+ Σ^- (primary vertex)
  Double_t Masses_2[2] = {1.19745,0.93827}; // sigma proton
  Double_t Masses_3[2] = {0.93957,0.13957}; // n, π^− (Σ^- decay into neutron and π^−)
  TLorentzVector Inv_Sigma; // 4-vector of reconstructed Σ^- from its daughter particles n, π^−

  // Creating decay vertices using TGenPhaseSpace class, which allows the generation of events in the CM of the reaction
  TGenPhaseSpace Vertex_1, Vertex_2, Vertex_3;

  // The Bremsstrahlung photon Beam is not monoenergetic, hence we need to generate the events within a certain range of energies, using a random number generator
  TRandom3 *rand = new TRandom3();
  gRandom = rand;

//========================================================================================================================================================

  // Looping over simulated events
  for (Long64_t i=0;i<nevents;i++){
    if (i % Percentage == 0){  // Counter, shows percentage of simulated events completed
      fprintf (stderr, "%lld\r", i/Percentage);
      fflush (stderr);
    }

    // Beam energy generated from 0 GeV to 2 GeV
    Double_t Beam_RND = gRandom->Uniform(1.05,2.3);
    Beam.SetPxPyPzE(0,0,Beam_RND, Beam_RND);   // photon Beam (LAB frame)
    h_Beam->Fill(Beam_RND);  // distribution histogram
    TLorentzVector V1 = Beam + target; // the energy of the center of momentum (CM

//========================================================================================================================================================
/*
  My interaction has 3 vertices

  Vertix 1 (photoproduction):   γn → K^+ Σ^-
  Vertix 2 (elastic scattering):  Σ^- p → Σ^- p
  vertix 3 (Σ^− decay, ~100% branching ratio): Σ^− → n π^−
*/
//========================================================================================================================================================

    // The first vertex γn → K^+ Σ^-
    Double_t V = Vertex_1.SetDecay(V1,2,Masses_1); // initial conditions (total energy, no. particles, mass array)
    if (!V) continue;  // MAKE SURE IT HAS ENOUGH ENERGY

    // Generating the event and defining the phasespace weight for the decay
    Phasespace_Weight_1 = Vertex_1.Generate();
    //Weight->Fill(Phasespace_Weight_1);
    // Assigning the decay particles
    Kaon_Plus      = Vertex_1.GetDecay(0);
    Sigma_Minus    = Vertex_1.GetDecay(1);

//========================================================================================================================================================

    // The second vertex (scattering)  Σ^-p → Σ^-p
    TLorentzVector V2 = (TLorentzVector)*Sigma_Minus + proton_trgt;
    // initial conditions (total energy, no. particles, mass array)
    Vertex_2.SetDecay(V2,2,Masses_2);
    // Generating the event and defining the phasespace weight for the decay
    Double_t Phasespace_Weight_2 = Vertex_2.Generate();
    // Assigning the decay particles
    Scattered_Sigma  = Vertex_2.GetDecay(0);
    Scattered_Proton = Vertex_2.GetDecay(1);

//========================================================================================================================================================

    // The third vertex (decay) Σ^- → n π^−
    TLorentzVector V3 = (TLorentzVector)*Scattered_Sigma; // total energy for second decay from Sigma-
    // initial conditions (total energy, no. particles, mass array)
    Vertex_3.SetDecay(V3,2,Masses_3);
    // Generating the event and defining the phasespace weight for the decay
    Double_t Phasespace_Weight_3 = Vertex_3.Generate();
    // Assigning the decay particles
    Neutron_Sigma  = Vertex_3.GetDecay(0);
    Pi_Minus_Sigma = Vertex_3.GetDecay(1);

    // Adding 4-vector of neutron and pion, used to find invariant mass of Sigma with .M()
    Inv_Sigma = (TLorentzVector)*Neutron_Sigma + (TLorentzVector)*Pi_Minus_Sigma;

  //========================================================================================================================================================

    // Path length calculations

    // Let the cylinder target be aligned with the z-axis and the cylinder centre located at (0,0,D/2)
    Double_t radius = 2;  // radius of cylinder in cm
    Double_t d = 40; // length of cylinder in cm
    // Generating points uniformly and randomly on a disc with the same radius as the cylinder
    Double_t phi = gRandom->Uniform(0, 2*TMath::Pi());  // azimuthal angle from uniformly distributed random numbers between 0,2pi
    Double_t r = sqrt(gRandom->Rndm())*radius; //multiply R (radius) by the square-root of a random number in [0, 1] to get the initial position
    Double_t z = gRandom->Uniform(0, d); // then choosing the distance along the axis uniformly
    //  Thus obtaining the cartesian points
    Double_t x = radius * TMath::Cos(phi);
    Double_t y = radius * TMath::Sin(phi);
    Double_t z = z; // symmetry

    // Defining angles for the  path length formula
    Double_t phi_v = (3/2)*TMath::Pi() - TMath::ATan(x/y); // phi vertix
    Double_t c = (r/radius)*TMath::Sin(phi_v - Sigma_Minus->Phi());
    Double_t alpha_R = phi + TMath::ASin(c);
    // prescribed angle between the radius R and position vector r to be used with law of cosines
    Double_t alpha = phi_v - alpha_R;
    // path length formula
    Double_t l = TMath::Sqrt(radius*radius + r*r - 2*radius*r*TMath::Cos(alpha));
    // the longitudinal path is
    Double_t l_p = l / TMath::Tan(Sigma_Minus->Theta());
    // and the z vertex of the exit position is
    Double_t z_exit = l_p + z;

    // Case 1: z_exit is ouside the target cell length (larger than d or smaller than 0) then the particle will exit from the end caps
    if (z_exit<0 || z_exit>d){
      if (Sigma_Minus->Theta() < TMath::Pi()/2){
        l_p = d-z; // longitudinal path for when θ < 90◦
      }
      else if (Sigma_Minus->Theta() > TMath::Pi()/2){
        l_p = z;  // longitudinal path for when θ > 90◦
      }
      Double_t path = l_p/TMath::Cos(Sigma_Minus->Theta());
    }
    // Case 2: z_exit is within the the target cell length (larger than 0 and smaller than d)
    else if (z>0 && z<d){
      Double_t path = l_p/TMath::Sin(Sigma_Minus->Theta());
    }

//========================================================================================================================================================

    // Decay path length

    /// Decay proability distribution, where cτ = 4.434 cm for Σ^
    TF1*decaypath = new TF1("decaypath", "TMath::Exp(-x/([0]*[1]*4.434))",0,100);
    // Parameters
    Double_t Sigma_Beta = Sigma_Minus->Beta();
    Double_t Sigma_Gamma = Sigma_Minus->Gamma();
    decaypath->SetParameter(0,Sigma_Beta);
    decaypath->SetParameter(1,Sigma_Gamma);
    // Simulate the decay path: use GetRandom to simulate a random number distributed according to the distribution of the decay proability function
    Double_t decay = decaypath->GetRandom();
    // where does the particle decay along the path length?
    if  (decay < path){
      Double_t decay_path_length = decay;
    }
    else if (decay > path){
      Double_t decay_path_length = path;
    }

    // decay coordinates
    Double_t x_decay = x + decay_path_length*TMath::Cos(Sigma_Minus->Phi());
    Double_t y_decay = y + decay_path_length*TMath::Sin(Sigma_Minus->Phi());
    Double_t r = x_decay*x_decay + y_decay*y_decay;
    Double_t z_decay = z + TMath::Sqrt(decay_path_length*decay_path_length-r);

//========================================================================================================================================================

// constraints (10 to 160 degrees for clas)
if (Kaon_Plus->Rho() > 0.2 && Scattered_Proton->Rho() > 0.2 && Pi_Minus_Sigma->Rho() > 0.2){
  if ((Kaon_Plus->Theta() > 10*TMath::DegToRad() && Kaon_Plus->Theta() < 160*TMath::DegToRad())){
    if ((Scattered_Proton->Theta() > 10*TMath::DegToRad() && Scattered_Proton->Theta() < 160*TMath::DegToRad())){
      if ((Pi_Minus_Sigma->Theta() > 10*TMath::DegToRad() && Pi_Minus_Sigma->Theta() < 160*TMath::DegToRad())){
        h_constrained_Kaon_Plus->Fill(Kaon_Plus->Theta()*TMath::RadToDeg(),Kaon_Plus->Rho(),Phasespace_Weight_1);
        h_constrained_Scattered_Proton->Fill(Scattered_Proton->Theta()*TMath::RadToDeg(),Scattered_Proton->Rho(),Phasespace_Weight_1*Phasespace_Weight_2);
        h_constrained_Pi_Minus_Sigma->Fill(Pi_Minus_Sigma->Theta()*TMath::RadToDeg(),Pi_Minus_Sigma->Rho(),Phasespace_Weight_1*Phasespace_Weight_2*Phasespace_Weight_3);
        h_constrained_Beam->Fill(Beam->Rho(),Phasespace_Weight_1);  // or all Phasespace_Weights ?
        h_constrained_Scattered_Sigma->Fill(Scattered_Sigma->Rho(),Phasespace_Weight_1*Phasespace_Weight_2);
      }
    }
  }
}

//========================================================================================================================================================

    // Filling histograms

    // Invariant mass
    h_inv_Sigma->Fill(Inv_Sigma.M(), Phasespace_Weight_1*Phasespace_Weight_3);
    h_Beam_rho->Fill(Beam->Rho());

    // Angular distributions (x,weights applied)
    h_Kaon_angles->Fill(Kaon_Plus->Theta()*TMath::RadToDeg(),Phasespace_Weight_1);
    h_Sigma_angles->Fill(Sigma_Minus->Theta()*TMath::RadToDeg(),Phasespace_Weight_1);

    // Momentum distributions (x,weights applied)
    h_Kaon_rho->Fill(Kaon_Plus->Rho(),Phasespace_Weight_1);
    h_Sigma_rho->Fill(Sigma_Minus->Rho(),Phasespace_Weight_1);
    h_Scattered_Sigma_rho->Fill(Scattered_Sigma->Rho(),Phasespace_Weight_1*Phasespace_Weight_2);

    // Angular dependence (x,weights applied)
    h_Kaon_Plus->Fill(Kaon_Plus->Theta()*TMath::RadToDeg(),Kaon_Plus->Rho(),Phasespace_Weight_1);
    h_Sigma_Minus->Fill(Sigma_Minus->Theta()*TMath::RadToDeg(),Sigma_Minus->Rho(),Phasespace_Weight_1);
    h_Scattered_Sigma->Fill(Scattered_Sigma->Theta()*TMath::RadToDeg(),Scattered_Sigma->Rho(),Phasespace_Weight_1*Phasespace_Weight_2);
    h_Scattered_Proton->Fill(Scattered_Proton->Theta()*TMath::RadToDeg(),Scattered_Proton->Rho(),Phasespace_Weight_1*Phasespace_Weight_2);
    h_Neutron_Sigma->Fill(Neutron_Sigma->Rho(),Neutron_Sigma->Theta()*TMath::RadToDeg(),Phasespace_Weight_1*Phasespace_Weight_2*Phasespace_Weight_3);
    h_Pi_Minus_Sigma->Fill(Pi_Minus_Sigma->Rho(),Pi_Minus_Sigma->Theta()*TMath::RadToDeg(), Phasespace_Weight_1*Phasespace_Weight_2*Phasespace_Weight_3);

    // Path length and decay histograms
    h_xyz->Fill(x,y,z);
    h_path->Fill(path);
    h_decaypath->Fill(decay_path_length);
    h_decay_xy->Fill(x_decay,y_decay);
    h_decay_z->Fill(z_decay);
    h_sigma_phi_xy->Fill(Sigma_Minus->Phi()*TMath::RadToDeg(),l);
    h_sigma_theta_z->Fill(Sigma_Minus->Theta()*TMath::RadToDeg(),l_p);
    h_path_theta->Fill(Sigma_Minus->Theta()*TMath::RadToDeg(),path);
    h_decaypath_theta->Fill(Sigma_Minus->Theta()*TMath::RadToDeg(),decay_path_length);

}
//=======================================================================================================================================================

    // Accepetance

    // Find acceptance by dividing histogram after angle cut by original histogram
    h_acceptance_Kaon_Plus->Divide(h_constrained_Kaon_Plus, h_Kaon_Plus);
    h_acceptance_Scattered_Proton->Divide(h_constrained_Scattered_Proton, h_Scattered_Proton);
    h_acceptance_Pi_Minus_Sigma->Divide(h_constrained_Pi_Minus_Sigma, h_Pi_Minus_Sigma);
    h_acceptance_Beam->Divide(h_constrained_Beam, h_Beam);
    h_acceptance_Scattered_Sigma->Divide(h_constrained_Scattered_Sigma, h_Scattered_Sigma_rho);

//========================================================================================================================================================

    // Luminosity

    // Liquid deuterium target parameters
    Double_t target_density = 0.1630; //  g cm^-3
    Double_t target_length = 40; // cm
    Double_t target_atomicmass = 2.014; // g/mol
    Double_t avgdr_num = 6.02E23; // avogadros number mol^-1

    /*
    The Σ^- beam luminosity is given by
          (Avogadro’s number * mass density of target * average pathlength of Σ^- beam * number of Σ^- particles) ÷ molar mass of target
    The average pathlength is given by
          h_decaypath->GetMean()
    The number of Σ^- particles is given by the cross section of K^+ Σ^- (denoted here by Beam_cs) from the relationship
          cross section = (number of Σ^- particles) ÷ beam luminosity
    The average K^+ Σ^- cross section is approximated in this simulation as 0.00900 which is the cross section for gamma n -> strange particles from
     https://lib-extopc.kek.jp/preprints/PDF/1991/9101/9101079.pdf
    */
    
     // Photon beam luminosity
    Double_t Beam_luminosity = nevents*target_density*target_length*(avgdr_num/target_atomicmass); // unit in cm^-2
    Double_t Beam_cs = 9.0E-30;  // cross section is 0.00900 millibarn (10^-27 cm^2), or  9.0 * 10^-30 cm^2

    // Secondoary beam (Σ^-) luminosity
    Double_t sigma_flux = Beam_cs*Beam_luminosity; // cm^-2 * cm^-2 cancels
    Double_t sigma_luminosity = sigma_flux*target_density*(h_decaypath->GetMean())*(avgdr_num/target_atomicmass);  // unit in cm^-2

    // Number of Σ^- particles produced produced over 100 days (conversion from s^-1 to 100 days is *60*60*24*100)
    cout<<"Total number of Sigma^- produced over 100 days: " << sigma_flux*60*60*24*100 << endl;
    // Number of scattered Σ^- produced over 100 days


//========================================================================================================================================================

//Writes histograms to file
fileOutput1.Write();

// Draw histograms
/*
TCanvas* c2 = new TCanvas("c2","stacked hists",5,5,1000,1000);
h_inv_Sigma->Draw("colz");
TCanvas* c3 = new TCanvas("c3","stacked hists",5,5,1000,1000);
h_Beam->Draw("colz");

TCanvas* c4 = new TCanvas("c4","stacked hists",5,5,1000,1000);
h_Kaon_angles->Draw("colz");
TCanvas* c5 = new TCanvas("c5","stacked hists",5,5,1000,1000);
h_Sigma_angles->Draw("colz");

TCanvas* c6 = new TCanvas("c6","stacked hists",5,5,1000,1000);
h_Kaon_rho->Draw("colz");
TCanvas* c7 = new TCanvas("c7","stacked hists",5,5,1000,1000);
h_Sigma_rho->Draw("colz");

TCanvas* c10 = new TCanvas("c10","stacked hists",5,5,1000,1000);
h_Kaon_Plus->Draw("colz");
TCanvas* c11 = new TCanvas("c11","stacked hists",5,5,1000,1000);
h_Sigma_Minus->Draw("colz");

TCanvas* c12 = new TCanvas("c12","stacked hists",5,5,1000,1000);
h_xyz->Draw();
TCanvas* c13 = new TCanvas("c13","stacked hists",5,5,1000,1000);
h_decay_xy->Draw("colz");
TCanvas* c14 = new TCanvas("c14","stacked hists",5,5,1000,1000);
h_decay_z->Draw("colz");
TCanvas* c15 = new TCanvas("c15","stacked hists",5,5,1000,1000);
h_decaypath->Draw("colz");
TCanvas* c16 = new TCanvas("c16","stacked hists",5,5,1000,1000);
h_Beam_rho->Draw("colz");

TCanvas* c17 = new TCanvas("c17","stacked hists",5,5,1000,1000);
h_constrained_Kaon_Plus->Draw("coltz");
TCanvas* c18 = new TCanvas("c18","stacked hists",5,5,1000,1000);
h_constrained_Scattered_Proton->Draw("coltz");
TCanvas* c20 = new TCanvas("c20","stacked hists",5,5,1000,1000);
h_constrained_Pi_Minus_Sigma->Draw("coltz");
TCanvas* c21 = new TCanvas("c21","stacked hists",5,5,1000,1000);
h_constrained_Beam->Draw("coltz");
TCanvas* c22 = new TCanvas("c22","stacked hists",5,5,1000,1000);
h_constrained_Scattered_Sigma->Draw("coltz");

TCanvas* c23 = new TCanvas("c23","stacked hists",5,5,1000,1000);
h_acceptance_Kaon_Plus->Draw("coltz");
TCanvas* c24 = new TCanvas("c24","stacked hists",5,5,1000,1000);
h_acceptance_Scattered_Proton->Draw("coltz");
TCanvas* c25 = new TCanvas("c25","stacked hists",5,5,1000,1000);
h_acceptance_Pi_Minus_Sigma->Draw("coltz");
TCanvas* c26 = new TCanvas("c26","stacked hists",5,5,1000,1000);
h_acceptance_Beam->Draw("coltz");
TCanvas* c27 = new TCanvas("c27","stacked hists",5,5,1000,1000);
h_acceptance_Scattered_Sigma->Draw("coltz");

TCanvas* c28 = new TCanvas("c28","stacked hists",5,5,1000,1000);
h_decaypath->Draw("coltz");
TCanvas* c29 = new TCanvas("c29","stacked hists",5,5,1000,1000);
h_sigma_phi_xy->Draw("coltz");
TCanvas* c30 = new TCanvas("c30","stacked hists",5,5,1000,1000);
h_sigma_theta_z->Draw("coltz");
TCanvas* c31 = new TCanvas("c31","stacked hists",5,5,1000,1000);
h_path_theta->Draw("coltz");
TCanvas* c32 = new TCanvas("c32","stacked hists",5,5,1000,1000);
h_decaypath_theta->Draw("coltz");
*/


}
